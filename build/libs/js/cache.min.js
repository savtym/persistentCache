'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//
// persistent.js
//

var counterRequest = 0;

var Persistent = function () {
  function Persistent(curId, curMaxSize) {
    _classCallCheck(this, Persistent);

    this._id = curId;
    this._maxMemory = curMaxSize;
    this._busyMemory = 0;
    this._lifeTime = {};
  }

  _createClass(Persistent, [{
    key: 'data',


    /*
    *   Get data from Local Storage by key
    *
    *   @key: when need get value by key (string) || empty: return all data
    */

    value: function data(key) {
      counterRequest++;

      if (key) {
        return JSON.parse(localStorage.getItem(this._id))[key];
      } else {
        return JSON.parse(localStorage.getItem(this._id));
      }
    }
  }, {
    key: 'insert',


    /*
    *   Insert data to Local Storage by key
    *
    *   @key: key set to Local Storage (string)
    *   @data: data set to Local Storage by key (any)
    *   @sizeData: how much data is occupied (number)
    */

    value: function insert(key, data, sizeData) {
      var freeSize = this.freeMemory;
      var values = this.data();

      if (values && values[key] && JSON.stringify(values[key]) === JSON.stringify(data)) {
        Storage._setKeyLifeTime(key, sizeData, this._lifeTime);
        return;
      }

      if (sizeData < freeSize) {

        counterRequest++;
        this._setValuesLocalStorage(key, data, values || {}, sizeData);
      } else if (sizeData < this._maxMemory) {

        var overwriting = Storage._leastRecentlyUsed(this._lifeTime, sizeData - freeSize);
        var _values = this.data();

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = overwriting[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                _key = _step$value[0],
                obj = _step$value[1];

            this._busyMemory -= obj.size;
            delete _values[_key];
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this._setValuesLocalStorage(key, data, _values, sizeData);
      } else {
        throw 'Max size localStorage is less than this data';
      }
    }

    /*
     *   Remove data from Local Storage by key
     *
     *   @key: key from Local Storage (string)
     */

  }, {
    key: 'remove',
    value: function remove(key) {
      var values = this.data();

      if (values[key]) {
        this._busyMemory -= this._lifeTime[key].size;
        delete values[key];
        counterRequest++;
        localStorage.setItem(this._id, JSON.stringify(values));
      }
    }

    /*
    *   Ancillary function for inserting into Local Storage
    *
    *   @key: key set to Local Storage (string)
    *   @data: data set to Local Storage by key (any)
    *   @values: values from Local Storage by key (any)
    *   @sizeData: how much data is occupied (number)
    *
    */

  }, {
    key: '_setValuesLocalStorage',
    value: function _setValuesLocalStorage(key, data, values, sizeData) {
      values[key] = data;
      this._busyMemory += sizeData;
      Storage._setKeyLifeTime(key, sizeData, this._lifeTime);
      counterRequest++;
      localStorage.setItem(this._id, JSON.stringify(values));
    }

    // static methods

  }, {
    key: 'maxMemory',
    get: function get() {
      return this._maxMemory;
    }
  }, {
    key: 'busyMemory',
    get: function get() {
      return this._busyMemory;
    }
  }, {
    key: 'freeMemory',
    get: function get() {
      return this._maxMemory - this._busyMemory;
    }
  }], [{
    key: 'counterRequest',
    get: function get() {
      return counterRequest;
    }
  }]);

  return Persistent;
}();
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RAM = function () {
  function RAM(curMaxSize) {
    _classCallCheck(this, RAM);

    this._maxMemory = curMaxSize;
    this._busyMemory = 0;
    this._lifeTime = {};
    this._data = {};
  }

  _createClass(RAM, [{
    key: 'data',


    /*
     *   Get data from Local Storage by key
     *
     *   @key: when need get value by key (string) || empty: return all data
     */

    value: function data(key) {
      if (key) {
        return this._data[key];
      } else {
        return this._data;
      }
    }
  }, {
    key: 'insert',


    /*
     *   Insert data to RAM
     *
     *   @key: key set to RAM (string)
     *   @data: data set to RAM by key (any)
     *   @sizeData: how much data is occupied (number)
     */

    value: function insert(key, data, sizeData) {
      var freeSize = this.freeMemory;

      if (sizeData < freeSize) {

        if (this._data[key]) {
          this._data[key] = {};
        }

        this._data[key] = data;
        this._busyMemory += sizeData;
        Storage._setKeyLifeTime(key, sizeData, this._lifeTime);
      } else if (sizeData < this._maxMemory) {

        var overwriting = Storage._leastRecentlyUsed(this._lifeTime, sizeData - freeSize);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = overwriting[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                _key = _step$value[0],
                obj = _step$value[1];

            this._busyMemory -= obj.size;
            delete this._data[_key];
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        throw 'Max size RAM is less than this data';
      }
    }

    /*
     *   Remove data from RAM by key
     *
     *   @key: key from RAM (string)
     */

  }, {
    key: 'remove',
    value: function remove(key) {
      if (this._data[key]) {
        this._busyMemory -= this._lifeTime[key].size;
        delete this._data[key];
      }
    }
  }, {
    key: 'maxMemory',
    get: function get() {
      return this._maxMemory;
    }
  }, {
    key: 'busyMemory',
    get: function get() {
      return this._busyMemory;
    }
  }, {
    key: 'freeMemory',
    get: function get() {
      return this._maxMemory - this._busyMemory;
    }
  }]);

  return RAM;
}();
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//
// storage.js
//

var globalSizeLocal = 5242880; // 5MB

var idMemory = 1;
var currentSizeMemoryRAM = 0;
var currentSizeMemoryPersistent = 0;

var defaultSizeRAM = 16384;
var defaultSizeLocal = 16384;

var storages = {};

var Storage = function () {
  function Storage() {
    var sizeRAM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16384;
    var sizeLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16384;

    _classCallCheck(this, Storage);

    sizeRAM = parseInt(sizeRAM);
    sizeLocal = parseInt(sizeLocal);

    sizeRAM = isNaN(sizeRAM) || sizeRAM < 0 ? defaultSizeRAM : sizeRAM;
    sizeLocal = isNaN(sizeLocal) || sizeLocal < 0 ? defaultSizeLocal : sizeLocal;

    if (Storage.freeMemoryLocal < sizeLocal) {
      throw 'Memory is full, clear cache!';
    }

    this._id = idMemory;
    this._ram = new RAM(sizeRAM);
    this._persistent = new Persistent(idMemory, sizeLocal);

    currentSizeMemoryRAM += sizeRAM;
    currentSizeMemoryPersistent += sizeLocal;

    storages[idMemory++] = this;
  }

  _createClass(Storage, [{
    key: 'data',


    /*
     *   Get data from RAM od Local Storage by key
     *
     *   @keyMemory: when need get value by key (string) || empty: return all data
     */

    value: function data(key) {

      if (typeof key !== 'string') {
        throw 'Key is not string';
      }

      var result = void 0;
      var busyMemory = this.busyMemory;

      if (key) {

        result = this._ram.data(key);

        if (result) {
          result = this._persistent.data(key);
        }
      } else {

        if (busyMemory.ram >= busyMemory.persistent) {
          result = this._ram.data();
        } else {
          result = this._persistent.data();
        }
      }

      return result;
    }

    /*
    *		Insert data by key
    *
    *   @key: key set to RAM and Local Storage
    *   @data: data set to RAM and Local Storage by key
    *
    */

  }, {
    key: 'insert',
    value: function insert(key, data) {

      if (typeof data === 'undefined') {
        throw 'Data is undefined';
      }

      key = typeof key === 'string' ? key : key.toString();

      this._ram.insert(key, data, Storage.sizeOf(data));
      this._persistent.insert(key, data, Storage.sizeOf(JSON.stringify(data)));
    }

    /*
     *   Remove data from Local Storage and RAM by key
     *
     *   @key: key from Local Storage and RAM (string)
     */

  }, {
    key: 'remove',
    value: function remove(key) {

      key = typeof key === 'string' ? key : key.toString();

      this._ram.remove(key);
      this._persistent.remove(key);
    }

    /*
     *   Clear cache by Local Storage and RAM
     *
     *   @cache: link to storage (link (class => function))
     */

  }, {
    key: 'clear',
    value: function clear() {
      currentSizeMemoryRAM -= this._ram.maxMemory;
      currentSizeMemoryPersistent -= this._persistent.maxMemory;

      localStorage.removeItem(this._id);
      delete storages[this._id];
    }

    // static methods


    /*
     *   Free memory space in the Local storage, by default in browsers is available 5 MB on one tab
     */

  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'freeMemory',
    get: function get() {
      return {
        ram: this._ram.freeMemory,
        persistent: this._persistent.freeMemory
      };
    }
  }, {
    key: 'busyMemory',
    get: function get() {
      return {
        ram: this._ram.busyMemory,
        persistent: this._persistent.busyMemory
      };
    }
  }, {
    key: 'maxMemory',
    get: function get() {
      return {
        ram: this._ram.maxMemory,
        persistent: this._persistent.maxMemory
      };
    }
  }], [{
    key: 'clearById',
    value: function clearById(id) {

      if (typeof id !== 'number' && typeof id !== 'string') {
        throw 'Id is not string or number';
      }

      if (storages[id]) {
        storages[id].clear();
      }
    }

    /*
     *		Clear full data from RAM and Local Storage
     */

  }, {
    key: 'clear',
    value: function clear() {
      currentSizeMemoryRAM = 0;
      currentSizeMemoryPersistent = 0;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = storages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var storage = _step.value;

          storage = null;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      storages = [];

      localStorage.clear();
    }

    /*
     *   Ancillary function for set key into life time object
     *
     *   @key: key set to Local Storage (string)
     *   @sizeData: how much data is occupied (number)
     *   @lifeTime: object that stores the key data ({ size: (number), time: (number) })
     *
     */

  }, {
    key: '_setKeyLifeTime',
    value: function _setKeyLifeTime(key, sizeData, lifeTime) {
      lifeTime[key] = {
        size: sizeData,
        time: new Date().getTime()
      };
    }

    /*
     *   Ancillary function for set key into life time object
     *
     *   @obj: how much memory (any)
     *
     */

  }, {
    key: 'sizeOf',
    value: function sizeOf(obj) {
      var bytes = 0;

      if (obj !== null && obj !== undefined) {
        switch (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) {
          case 'number':
            bytes += 8;
            break;
          case 'string':
            bytes += obj.length * 2;
            break;
          case 'boolean':
            bytes += 4;
            break;
          case 'object':
            var objClass = Object.prototype.toString.call(obj).slice(8, -1);
            if (objClass === 'Object' || objClass === 'Array') {
              for (var key in obj) {
                if (!obj.hasOwnProperty(key)) {
                  continue;
                }
                bytes += Storage.sizeOf(obj[key]);
              }
            } else {
              bytes += JSON.stringify(obj).length * 2;
            }
            break;
        }
      }

      return bytes;
    }
  }, {
    key: '_leastRecentlyUsed',


    /*
    *		Ancillary function for Least Recently Used (LRU) data
    *
    *   @lifeTime: object that stores the key data ({ size: (number), time: (number) })
    *		@needSize: how need memory size for data
    *
    */

    value: function _leastRecentlyUsed(lifeTime, needSize) {

      var result = [];
      var sortable = [];
      var curSizeFree = 0;

      for (var key in lifeTime) {
        sortable.push([key, lifeTime[key]]);
      }

      sortable.sort(function (a, b) {
        return a[1].time - b[1].time;
      });

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = sortable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              _key = _step2$value[0],
              obj = _step2$value[1];

          result.push([_key, obj]);
          curSizeFree += obj.size;
          if (curSizeFree >= needSize) {
            break;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return result;
    }
  }, {
    key: 'maxMemoryLocal',
    get: function get() {
      return globalSizeLocal;
    }
  }, {
    key: 'freeMemoryLocal',
    get: function get() {
      return globalSizeLocal - Storage.sizeOf(localStorage);
    }

    /*
    * 		Counter request to Local Storage
    */

  }, {
    key: 'counterRequest',
    get: function get() {
      return Persistent.counterRequest;
    }
  }]);

  return Storage;
}();

exports.default = Storage;